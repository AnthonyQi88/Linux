# 关于Shell Scripting的最直观基础知识
# 术语
日语|中文|英语|   <->   |日语|中文|英语
:---|:---:|---:|:---:|---:|:---|---:
引数・パラメーター|参数|parameter||端数|余数|fraction{omit/round off~}
変数|变量|variable||整数||integer
正数・正の数||positive number||負数・負の数||negative number
真シン||True||偽ギ||False
ブール演算式・論理式|布尔运算|Boolean||演算子||operator
左辺１||Left||右辺１||Right
等式||equality||不等式||inequality
論理和・選言|或判断|Logical disjunction/OR operation||論理積・連言|和判断|Logical conjunction/AND operation
配列|数组|Array||連想配列・ディクショナリ|字典|Associative Array・dictionary
短絡||bybass||

# 索引
编号|内容
---|---
1000| 计算（算術式）
1001| 四則演算・剰り求め・累乗・括弧
1002| 進数
1003| インクリメント・デクリメント
1004| 比較演算・関係演算子
1005| 論理演算
1006| (複合)代入演算子
1007| カンマ演算子
1008| 配列・連想配列・配列の添字
1009| 条件演算子
1010| letコマンド
1011| for ((～; ～; ～))ループ
1012| パラメータ・変数展開の offset/length
1013| 整数属性のついた変数に代入する時 declare -i var=算術式
1014| 1014 条件コマンド内の整数比較演算子のオペランド \[\[ ～ -eq ～ ]]
1015| 算術式で参照した変数・配列要素の中身

# 内容
## 1000 计算
### 1001 四則演算・剰り求め・累乗
[root@localhost Documents]# i=10

计算式|计算示例|计算结果
:---|:---:|---:
乘法・掛け算  |echo $((10\*10))| 100
除法・割り算  |echo $((5/2))  | 2(端数切り捨て)
加法・足し算  |echo $((i+2))  | 12
减法・引き算  |echo $((i-2))  | 8
余数・剰り  　|echo $((i%2))  | 0
平方・累乗    |echo $((2\*\*3)) | 8
括弧・優先順位 |echo $((1+2\*3)) | 7 (先に 2\*3 が計算されて 6 になり、次に 1+6 が計算される)
括弧・優先順位 |echo $(((1+2)\*3)) | 9 (先に 1+2 が計算されて 3 になり、次に 3\*3 が計算される)

### 1002 進数
進数|実行例|結果|説明
---|---|---|---
10 |echo $((1234))|1024|1-9の数字で始まる数字の並びです。
8  |echo $((0755))|493|0 から始まる整数は 8 進表記と解釈されます。
16 |echo $((0xFF)) $((0X100))|255 256|0x もしくは 0X で始まる整数は 16 進数と解釈されます。
指定進数|echo $((2#10111011)) $((64#aK3))|187 43907|好きなn進数の表記を取り扱うこともできます。n#数の形式で指定します。

### 1003 インクリメント・デクリメント

前置インクリメント ++変数名 は変数の中身を1増やします。前置デクリメント --変数名 は変数の中身を1減らします。評価結果は変更後の変数の中身です。
```shell
前置インクリメント・デクリメント
i=2016
echo $((++i)) # 結果: 2017
echo $i # 結果: 2017
echo $((--i)) # 結果: 2016
echo $i # 結果: 2016
```
後置インクリメント 変数名++ と後置デクリメント 変数名-- も同様ですが、評価結果が変更前の変数の中身ということが違います。
```shell
後置インクリメント・デクリメント
i=2016
echo $((i++)) # 結果: 2016
echo $i # 結果: 2017
echo $((i--)) # 結果: 2017
echo $i # 結果: 2016
```
### 1004 比較演算
比較演算ももちろんあります。結果が真の時は 1 で、偽の時は 0 です。
```shell
等・不等
echo $((0==1)) # 等号、結果: 0
echo $((0!=1)) # 否定等号、結果: 1
echo $((0<1)) # 未満、結果: 1
echo $((0<=1)) # 以下、結果: 1
echo $((0>1)) # 大なり、結果: 0
echo $((0>=1)) # 以上、結果: 0
```
### 1005 論理演算
論理積・論理和も計算できます。左辺および右辺は 0 以外の時に真と解釈され、0 の時に偽と解釈されます。結果は、真の時に 1 で偽のときに 0 になります。
```shell
論理積・論理和
echo $((1&&0)) # 結果: 0
echo $((1||0)) # 結果: 1
```
また、&& の右辺の評価結果が偽だったときには (右辺を評価しなくても全体の結果が偽と確定するので) 右辺は評価されません。同様に、|| の左辺が真だったときには右辺は評価されません。
```shell
論理積・論理和の短絡評価
i=0 j=0
echo $((i++ && j++)) # 結果: 0 
echo $i $j # 結果: 1 0 (上で i++ が偽になり、j++ は実行されない)

i=0 j=0
echo $((++i || ++j)) # 結果: 1
echo $i $j # 結果: 1 0 (上で ++i が真になり、++j は評価されない)
```
### 1006 (複合)代入演算子
変数に対する値の代入もできます。評価結果は代入後の変数の値です。
```shell
代入演算子
echo $((a=1234)) # 結果: 1234
echo $a # 結果: 1234

複合代入演算子
a=1234
echo $((a+=10)) # a=a+10 に同じ、結果: 1244
echo $((a-=10)) # a=a-10 に同じ、結果: 1234
echo $((a*=10)) # a=a*10 に同じ、結果: 12340
echo $((a/=10)) # a=a/10 に同じ、結果: 1234
echo $((a%=10)) # a=a%10 に同じ、結果: 4
echo $((a<<=6)) # a=a<<6 に同じ、結果: 256
echo $((a>>=2)) # a=a>>2 に同じ、結果: 64
echo $((a|=63)) # a=a|63 に同じ、結果: 127
echo $((a&=63)) # a=a&10 に同じ、結果: 63
echo $((a^=15)) # a=a^10 に同じ、結果: 48
```
### 1007 カンマ演算子
カンマで区切って複数の式を指定することができます。評価結果は右辺の結果になります。
```shell
echo $((a=1,b=2)) # 結果: 2
echo $a $b # 結果: 1 2
```
### 1008　配列・連想配列
Bash には配列・連想配列が存在します。その要素を参照することもできます。

配列の場合には 配列名[算術式] とします。
```shell
配列要素
arr=(111 222 333)
echo $((arr[1])) # 結果: 222
```
連想配列の場合には 連想配列名[文字列] とします。
```shell
連想配列要素
declare -A dict=([hello]=1234 [world]=4321)
echo $((dict[world])) $((dict[hello])) # 結果: 4321 1234
```
配列・連想配列添字だけの特別ルールとして、添字を解釈する前にコマンド置換・変数展開・算術式展開などのシェル展開が 要素の参照時 に実行されます。ただし、$(()) に算術式が渡される前に展開されないように $ のエスケープ (つまり \$ のようにする) が必要です。
```shell
配列添字のシェル展開
arr=(111 222 333)
index=0
echo $((index=2,arr[\$(echo \$index)])) # 結果: 333

# 以下は、比較のため
index=0
echo $((index=2,arr[$(echo $index)])) # 結果: 111
```
連想配列の場合も同様です。
```shell
連想配列添字のシェル展開
declare -A dict=([hello]=1234 [world]=4321)
echo $((arr[\$(echo world)])) # 結果: 4321
```
#### 配列要素への代入 arr[～]=value
配列要素に代入を行う時の添字は算術式です: 配列名[算術式]=値。
```SHELL
配列要素代入の添字
arr[1+1]=hello
arr[2*3]=world
declare -p arr # 結果: declare -a arr='([2]="hello" [6]="world")'
```
#### 配列初期化時の添字 arr=([～]=value)
配列を一括で初期化する時に指定する添字も算術式です: 配列名=([算術式]=値)。
```shell
配列初期化時の添字
arr=([1+1]=hello [2*3]=world)
declare -p arr # 結果: declare -a arr='([2]="hello" [6]="world")'
```
#### 配列要素の展開時の添字 ${arr[～]}
配列要素を変数展開で参照する時 ${arr[算術式]} に指定する添字も算術式です。
```shell
配列要素の展開時の添字
arr=([2]=hello [6]=world)
echo ${arr[5+1]} # 結果: world
```
#### 配列要素 unset 時の添字 unset 'arr[～]'
配列要素を unset を用いて削除する時 unset 'arr[算術式]' に指定する添字も算術式です。
```shell
配列要素の unset 時の添字
arr=([0]=hello [1]=arithmetic [2]=world)
unset 'arr[(4-1)*2-5]'
echo "${arr[*]}" # 結果: hello world
```
※因みに unset に配列要素・連想配列要素を指定する時は必ず \[] をクォートする必要があります (全体を囲んで "arr\[～]" や 'arr\[～]' の様にするか、arr\[～\] などの様にする)。クォートを忘れると、たまたま arr0 の様なファイルがカレントディレクトリにあったり、シェルのオプションで failglob や nullglob が設定されたりしている時に誤動作します。

### 1009 条件演算子
条件演算子 ?: は 式1?式2:式3 の形で使用します。先ず式1を評価します。式1の評価結果が真 (0以外) の場合に、式2を評価してその結果を返します。式1の評価結果が偽 (0) の場合に、式3を評価してその結果を返します。
式1の評価結果が真の場合は式3は評価されません。式1の評価結果が偽の場合は式2は評価されません (短絡評価)。
```shell
#条件演算子
echo $((1234?111:222)) # 結果: 111

#条件演算子の短絡評価
i=0 j=0
echo $((1234?i++:j++)) # i++ が実行される。j++は実行されない。
echo $i $j # 結果: 1 0

i=0 j=0
echo $((0?i++:j++)) # j++ が実行される。i++は実行されない。
echo $i $j # 結果: 0 1
```
### letコマンド
算術式を評価する let というコマンドもあります。let 算術式 [算術式...] という形で指定します。各引数はそれぞれ独立した算術式として左から順に評価されます。
```shell
let a=1 b=2 c=a+b
echo $? $c # 結果: 0 3
```
引数は一つ以上指定する必要があります。let コマンドの終了ステータスは、最後の算術式の評価結果が、0 以外の時に成功 (0) で 0 の時・構文エラーの時に失敗 (1) です。

let は算術式専用の文法 (()) と違って通常のコマンドと同じ形式を取ります。つまり、()<>&\*?\[ などの文字はシェルコマンドの特別な文字と見なされてしまうので、算術式としてそのまま使えません。代わりに \ でエスケープするか、算術式全体を '～' などでクォートする必要があります。
```shell
let 記号類のクォート
let 2>1 # 駄目。2>1 はファイルディスクリプタ 2 から
        # ファイル 1 へのリダイレクトと見なされてしまう
let '2>1' # OK
let 2\>1 # OK

let (1+2)*3 # 駄目。シェルの構文エラー
let '(1+2)*3' # OK
let \(1+2\)\*3 # OK

let 2*3 # 駄目。例えば shopt -s nullglob のとき
        # * のパス名展開に失敗して式が消滅する。
        # もしくは一致したファイル名が算術式として実行される。
let '2*3' # OK
let 2\*3 # OK
```
この理由から基本的には let ではなく (()) を使う方が推奨されます。
### 1011 for ((～; ～; ～))ループ
また for 文の特別な形式として for ((式1;式2;式3)) というものを使うことができます。C言語の for 文と同様に、式1 が一番初めに評価され、式2 の評価結果が真である間 for 文の中身を繰り返し実行します。ループの最後で次のループに移る前に 式3 が評価されます。
```shell
for ((i=0;i<10;i++)); do
  echo $i
done
```
ループの継続条件 (式2) を省略した時は真と解釈され無限ループになりますので break が必要です。
Bash では for キーワードの後の空白は省略可能です (Zsh では省略できません)。

### 1012 パラメータ・変数展開の offset/length
パラメータ・変数展開では ${変数名:開始点} または ${変数名:開始点:長さ} とすることで変数の中身の部分文字列を取り出すことができます。Bash では、この時の開始点 (offset) 及び長さ (length) の部分に指定するのも算術式です。
```shell
パラメータ展開
a=hello
echo ${a:1+1} # 結果: llo
echo ${a:2-1:1+2} # 結果: ell
```
また、配列要素の列を展開するときの offset/length も同様に算術式です。
```shell
配列要素の展開
arr=(spring summer autumn winter)
echo "${arr[@]:2-1}" # 結果: summer autumn winter
echo "${arr[@]:0:1+1}" # 結果: spring summer
```
### 1013 整数属性のついた変数に代入する時 declare -i var=算術式
Bash のシェル変数には整数属性を付加することができます。整数属性の付いたシェル変数に代入 (変数=算術式) を行うと、代入しようとした文字列について算術式評価が実行され、その結果が変数に格納されます。

整数属性を付加するには declare/typeset/local/readonly コマンドに -i オプションを指定して変数を宣言します。
もちろん宣言と同時に代入をした時も算術式評価が行われます (declare -i 変数名=算術式)。
```shell
declare -i 変数名
declare -i var
var=1+2*3
echo $var # 結果: 7

readonly -i 変数名=算術式
readonly -i ABC=1*2*3
echo $ABC # 結果: 6
```
### 1014 条件コマンド内の整数比較演算子のオペランド \[\[ ～ -eq ～ ]]
また Bash の条件コマンド \[\[ ～ ]] の中で整数比較の演算子 -eq, -ne, -lt, -le, -gt, -ge を使う時、その左辺・右辺は算術式評価の対象です。つまり、\[\[ 算術式 -eq 算術式 ]] の様になります。
```shell
条件コマンドの整数の比較演算子
[[ 1+1 -eq 2-2 ]]; echo $? # 左辺 ＝ 右辺、結果: 1
[[ 1+1 -ne 2-2 ]]; echo $? # 左辺 ≠ 右辺、結果: 0
[[ 1+1 -lt 2-2 ]]; echo $? # 左辺 ＜ 右辺、結果: 1
[[ 1+1 -le 2-2 ]]; echo $? # 左辺 ≦ 右辺、結果: 1
[[ 1+1 -gt 2-2 ]]; echo $? # 左辺 ＞ 右辺、結果: 0
[[ 1+1 -ge 2-2 ]]; echo $? # 左辺 ≧ 右辺、結果: 0
```
但し、test コマンドや \[ コマンドの場合には、上記の演算子の引数は算術式評価の対象となりません。

この機能は長らくドキュメントに書かれていませんでしたが、Chet が 2017-03-04 に \[bug-bash] Re: -eq and strings でドキュメントに書くと言いました。

### 1015 算術式で参照した変数・配列要素の中身
算術式中で参照した変数・配列要素の値を取り出す時にも、変数に格納された文字列に対して算術式評価が起こります。つまり、再帰的に算術式の呼び出しが起こります。
```shell
変数・配列要素の参照時に算術式評価
var=1+2*3
echo $var # 結果: 1+2*3
echo $((3*var)) # 結果: 21
                # 注意: 3*1+2*3 になってから評価されるのではなく、
                # var から値を取り出す時に算術式評価が起こって 3*7 が得られる。
                
但し、代入式 a=x の左辺に来た変数名・配列要素の場合には、中身の算術式評価は起こりません。
代入式の左辺にある変数名・配列要素は評価されない
i=0 expr=i++
echo $((expr=3,i)) # 結果: 0

多段階の再帰も可能です。
i=0
expr1=i++
expr2=expr1,expr1,expr1
echo $((expr2,expr2,i)) # 結果: 6
```
ただし、再帰の深さには限界があって、(現行の bash-3.0 ～ 4.4 で) 1022 段までしかできません。

